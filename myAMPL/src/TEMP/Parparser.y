-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parparser where
import Absparser
import Lexparser
import ErrM

}

%name pAMPLCODE AMPLCODE
%name pHANDLE_SPEC HANDLE_SPEC
%name pHandle Handle
%name pListHANDLE_SPEC ListHANDLE_SPEC
%name pListHandle ListHandle
%name pCONSTRUCTORS CONSTRUCTORS
%name pDESTRUCTORS DESTRUCTORS
%name pSTRUCTOR_SPEC STRUCTOR_SPEC
%name pSTRUCT STRUCT
%name pListSTRUCTOR_SPEC ListSTRUCTOR_SPEC
%name pListSTRUCT ListSTRUCT
%name pHANDLES HANDLES
%name pCOHANDLES COHANDLES
%name pPROCESSES PROCESSES
%name pListPROCESS_SPEC ListPROCESS_SPEC
%name pPROCESS_SPEC PROCESS_SPEC
%name pVars Vars
%name pListVars ListVars
%name pFUNCTIONS FUNCTIONS
%name pListFUNCTION_SPEC ListFUNCTION_SPEC
%name pFUNCTION_SPEC FUNCTION_SPEC
%name pSTART START
%name pCHANNEL_SPEC CHANNEL_SPEC
%name pCOMS COMS
%name pListCOM ListCOM
%name pCOM COM
%name pLABELCOMS LABELCOMS
%name pListCOMS ListCOMS
%name pListLABELCOMS ListLABELCOMS
%name pListNCInteger ListNCInteger
%name pListNIdent ListNIdent
%name pListIdent ListIdent
%name pListTRAN ListTRAN
%name pTRAN TRAN
%name pNCInteger NCInteger
%name pNIdent NIdent
%name pCInteger CInteger
%name pListCInteger ListCInteger

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '%cohandles' { PT _ (TS _ 1) }
 '%constructors' { PT _ (TS _ 2) }
 '%destructors' { PT _ (TS _ 3) }
 '%functions' { PT _ (TS _ 4) }
 '%handles' { PT _ (TS _ 5) }
 '%processes' { PT _ (TS _ 6) }
 '%run' { PT _ (TS _ 7) }
 '(' { PT _ (TS _ 8) }
 ')' { PT _ (TS _ 9) }
 ',' { PT _ (TS _ 10) }
 '-' { PT _ (TS _ 11) }
 '.' { PT _ (TS _ 12) }
 ':' { PT _ (TS _ 13) }
 ':=' { PT _ (TS _ 14) }
 ';' { PT _ (TS _ 15) }
 '=' { PT _ (TS _ 16) }
 '=>' { PT _ (TS _ 17) }
 'IN' { PT _ (TS _ 18) }
 'OUT' { PT _ (TS _ 19) }
 '[' { PT _ (TS _ 20) }
 ']' { PT _ (TS _ 21) }
 'add' { PT _ (TS _ 22) }
 'as' { PT _ (TS _ 23) }
 'cInt' { PT _ (TS _ 24) }
 'call' { PT _ (TS _ 25) }
 'case' { PT _ (TS _ 26) }
 'close' { PT _ (TS _ 27) }
 'cons' { PT _ (TS _ 28) }
 'dest' { PT _ (TS _ 29) }
 'fork' { PT _ (TS _ 30) }
 'fret' { PT _ (TS _ 31) }
 'get' { PT _ (TS _ 32) }
 'halt' { PT _ (TS _ 33) }
 'hcase' { PT _ (TS _ 34) }
 'hput' { PT _ (TS _ 35) }
 'into' { PT _ (TS _ 36) }
 'leq' { PT _ (TS _ 37) }
 'load' { PT _ (TS _ 38) }
 'mul' { PT _ (TS _ 39) }
 'of' { PT _ (TS _ 40) }
 'plug' { PT _ (TS _ 41) }
 'put' { PT _ (TS _ 42) }
 'rec' { PT _ (TS _ 43) }
 'ret' { PT _ (TS _ 44) }
 'run' { PT _ (TS _ 45) }
 'split' { PT _ (TS _ 46) }
 'store' { PT _ (TS _ 47) }
 'with' { PT _ (TS _ 48) }
 '{' { PT _ (TS _ 49) }
 '|' { PT _ (TS _ 50) }
 '}' { PT _ (TS _ 51) }

L_integ  { PT _ (TI $$) }
L_ident  { PT _ (TV $$) }
L_UIdent { PT _ (T_UIdent $$) }
L_err    { _ }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Ident   :: { Ident }   : L_ident  { Ident $1 }
UIdent    :: { UIdent} : L_UIdent { UIdent ($1)}

AMPLCODE :: { AMPLCODE }
AMPLCODE : HANDLES COHANDLES CONSTRUCTORS DESTRUCTORS PROCESSES FUNCTIONS START { Main $1 $2 $3 $4 $5 $6 $7 } 


HANDLE_SPEC :: { HANDLE_SPEC }
HANDLE_SPEC : UIdent '=' '{' ListHandle '}' { Hand_spec $1 $4 } 


Handle :: { Handle }
Handle : UIdent { HandName $1 } 


ListHANDLE_SPEC :: { [HANDLE_SPEC] }
ListHANDLE_SPEC : {- empty -} { [] } 
  | HANDLE_SPEC { (:[]) $1 }
  | HANDLE_SPEC ';' ListHANDLE_SPEC { (:) $1 $3 }


ListHandle :: { [Handle] }
ListHandle : Handle { (:[]) $1 } 
  | Handle ';' ListHandle { (:) $1 $3 }


CONSTRUCTORS :: { CONSTRUCTORS }
CONSTRUCTORS : '%constructors' ':' '{' ListSTRUCTOR_SPEC '}' { Constructors $4 } 
  | {- empty -} { Constructors_none }


DESTRUCTORS :: { DESTRUCTORS }
DESTRUCTORS : '%destructors' ':' '{' ListSTRUCTOR_SPEC '}' { Destructors $4 } 
  | {- empty -} { Destructors_none }


STRUCTOR_SPEC :: { STRUCTOR_SPEC }
STRUCTOR_SPEC : UIdent '=' '{' ListSTRUCT '}' { Struct_spec $1 $4 } 


STRUCT :: { STRUCT }
STRUCT : UIdent Integer { Struct $1 $2 } 


ListSTRUCTOR_SPEC :: { [STRUCTOR_SPEC] }
ListSTRUCTOR_SPEC : {- empty -} { [] } 
  | STRUCTOR_SPEC { (:[]) $1 }
  | STRUCTOR_SPEC ';' ListSTRUCTOR_SPEC { (:) $1 $3 }


ListSTRUCT :: { [STRUCT] }
ListSTRUCT : STRUCT { (:[]) $1 } 
  | STRUCT ';' ListSTRUCT { (:) $1 $3 }


HANDLES :: { HANDLES }
HANDLES : '%handles' ':' '{' ListHANDLE_SPEC '}' { Handles $4 } 
  | {- empty -} { Handles_none }


COHANDLES :: { COHANDLES }
COHANDLES : '%cohandles' ':' '{' ListHANDLE_SPEC '}' { Cohandles $4 } 
  | {- empty -} { Cohandles_none }


PROCESSES :: { PROCESSES }
PROCESSES : '%processes' ':' '{' ListPROCESS_SPEC '}' { Processes $4 } 
  | {- empty -} { Processes_none }


ListPROCESS_SPEC :: { [PROCESS_SPEC] }
ListPROCESS_SPEC : {- empty -} { [] } 
  | PROCESS_SPEC { (:[]) $1 }
  | PROCESS_SPEC ';' ListPROCESS_SPEC { (:) $1 $3 }


PROCESS_SPEC :: { PROCESS_SPEC }
PROCESS_SPEC : Ident '(' ListVars '|' ListIdent '=>' ListIdent ')' '=' COMS { Process_spec $1 $3 $5 $7 $10 } 


Vars :: { Vars }
Vars : Ident { VName $1 } 


ListVars :: { [Vars] }
ListVars : {- empty -} { [] } 
  | Vars { (:[]) $1 }
  | Vars ',' ListVars { (:) $1 $3 }


FUNCTIONS :: { FUNCTIONS }
FUNCTIONS : '%functions' ':' '{' ListFUNCTION_SPEC '}' { Functions $4 } 
  | {- empty -} { Functions_none }


ListFUNCTION_SPEC :: { [FUNCTION_SPEC] }
ListFUNCTION_SPEC : {- empty -} { [] } 
  | FUNCTION_SPEC { (:[]) $1 }
  | FUNCTION_SPEC ';' ListFUNCTION_SPEC { (:) $1 $3 }


FUNCTION_SPEC :: { FUNCTION_SPEC }
FUNCTION_SPEC : Ident '(' ListVars ')' '=' COMS { Function_spec $1 $3 $6 } 


START :: { START }
START : '%run' CHANNEL_SPEC ':' COMS { Start $2 $4 } 


CHANNEL_SPEC :: { CHANNEL_SPEC }
CHANNEL_SPEC : '(' '|' ListIdent '=>' ListIdent ')' { Channel_specf $3 $5 } 
  | '(' ListCInteger '=>' ListCInteger ')' { Channel_spec $2 $4 }


COMS :: { COMS }
COMS : '{' ListCOM '}' { Prog $2 } 


ListCOM :: { [COM] }
ListCOM : {- empty -} { [] } 
  | COM { (:[]) $1 }
  | COM ';' ListCOM { (:) $1 $3 }


COM :: { COM }
COM : 'store' Ident { AC_STOREf $2 } 
  | 'load' Ident { AC_LOADf $2 }
  | 'ret' { AC_RET }
  | 'fret' { AC_FRET }
  | 'call' Ident '(' ListIdent ')' { AC_CALLf $2 $4 }
  | 'cInt' CInteger { AC_INT $2 }
  | 'leq' { AC_LEQ }
  | 'add' { AC_ADD }
  | 'mul' { AC_MUL }
  | 'cons' '(' Integer ',' Integer ')' { AC_CONS $3 $5 }
  | UIdent '.' UIdent { AC_STRUCT $1 $3 }
  | UIdent '.' UIdent '(' ListIdent ')' { AC_STRUCTas $1 $3 $5 }
  | 'case' 'of' '{' ListLABELCOMS '}' { AC_CASEf $4 }
  | 'rec' 'of' '{' ListLABELCOMS '}' { AC_RECORDf $4 }
  | 'dest' Integer Integer { AC_DEST $2 $3 }
  | 'get' Ident { AC_GETf $2 }
  | 'hput' Ident UIdent '.' UIdent { AC_HPUTf $2 $3 $5 }
  | 'hcase' Ident 'of' '{' ListLABELCOMS '}' { AC_HCASEf $2 $5 }
  | 'put' Ident { AC_PUTf $2 }
  | 'split' Ident 'into' Ident Ident { AC_SPLITf $2 $4 $5 }
  | 'fork' Ident 'as' '{' Ident 'with' ListIdent 'as' COMS ';' Ident 'with' ListIdent 'as' COMS '}' { AC_FORKf $2 $5 $7 $9 $11 $13 $15 }
  | 'plug' Ident 'with' '{' '[' ListIdent ']' ':' COMS ';' '[' ListIdent ']' ':' COMS '}' { AC_PLUGf $2 $6 $9 $12 $15 }
  | 'run' Ident '(' ListIdent '|' ListIdent '=>' ListIdent ')' { AC_RUNf $2 $4 $6 $8 }
  | Ident ':=' Ident { AC_IDF $1 $3 }
  | 'close' Ident { AC_CLOSEf $2 }
  | 'halt' Ident { AC_HALTf $2 }


LABELCOMS :: { LABELCOMS }
LABELCOMS : UIdent '.' UIdent ':' COMS { Labelcoms1 $1 $3 $5 } 
  | UIdent '.' UIdent '(' ListIdent ')' ':' COMS { Labelcoms2 $1 $3 $5 $8 }


ListCOMS :: { [COMS] }
ListCOMS : {- empty -} { [] } 
  | COMS { (:[]) $1 }
  | COMS ',' ListCOMS { (:) $1 $3 }


ListLABELCOMS :: { [LABELCOMS] }
ListLABELCOMS : {- empty -} { [] } 
  | LABELCOMS { (:[]) $1 }
  | LABELCOMS ';' ListLABELCOMS { (:) $1 $3 }


ListNCInteger :: { [NCInteger] }
ListNCInteger : NCInteger { (:[]) $1 } 
  | NCInteger ',' ListNCInteger { (:) $1 $3 }


ListNIdent :: { [NIdent] }
ListNIdent : NIdent { (:[]) $1 } 
  | NIdent ',' ListNIdent { (:) $1 $3 }


ListIdent :: { [Ident] }
ListIdent : {- empty -} { [] } 
  | Ident { (:[]) $1 }
  | Ident ',' ListIdent { (:) $1 $3 }


ListTRAN :: { [TRAN] }
ListTRAN : {- empty -} { [] } 
  | TRAN { (:[]) $1 }
  | TRAN ',' ListTRAN { (:) $1 $3 }
  | {- empty -} { [] }
  | TRAN { (:[]) $1 }
  | TRAN ';' ListTRAN { (:) $1 $3 }


TRAN :: { TRAN }
TRAN : '(' Integer ',' 'IN' ',' Integer ')' { TranIn11 $2 $6 } 
  | '(' Integer ',' 'OUT' ',' Integer ')' { TranIn12 $2 $6 }


NCInteger :: { NCInteger }
NCInteger : CInteger { Ncinteger $1 } 


NIdent :: { NIdent }
NIdent : Ident { Nident1 $1 } 


CInteger :: { CInteger }
CInteger : Integer { Positive $1 } 
  | '-' Integer { Negative $2 }


ListCInteger :: { [CInteger] }
ListCInteger : {- empty -} { [] } 
  | CInteger { (:[]) $1 }
  | CInteger ',' ListCInteger { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

